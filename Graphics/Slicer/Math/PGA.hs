{-
 - Copyright 2020 Julia Longtin
 -
 - This program is free software: you can redistribute it and/or modify
 - it under the terms of the GNU Affero General Public License as published by
 - the Free Software Foundation, either version 3 of the License, or
 - (at your option) any later version.
 -
 - This program is distributed in the hope that it will be useful,
 - but WITHOUT ANY WARRANTY; without even the implied warranty of
 - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 - GNU Affero General Public License for more details.

 - You should have received a copy of the GNU Affero General Public License
 - along with this program.  If not, see <http://www.gnu.org/licenses/>.
 -}

{- The purpose of this file is to hold projective geometric algebraic arithmatic. -}

-- for adding Generic and NFData to our types.
{-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}

module Graphics.Slicer.Math.PGA(PPoint2(PPoint2), PLine2(PLine2), eToPPoint2, canonicalizePPoint2, eToPLine2, combineConsecutiveLines, lineIntersection, dualPPoint2, dualPLine2, dual2DGVec, join2PPoint2) where

import Prelude (Eq, Show, error, (==), ($), filter, (*), (-), Bool, (&&), last, init, (++), length, (<$>), otherwise, (>), (<=), (+), foldl, sqrt)

import GHC.Generics (Generic)

import Control.DeepSeq (NFData)

import Data.List.Ordered (foldt)

import Data.Maybe (Maybe(Just, Nothing), isJust)

import Graphics.Slicer.Definitions (ℝ)

import Graphics.Slicer.Math.Definitions(Point2(Point2), Contour(PointSequence), addPoints)

import Graphics.Slicer.Math.Line(Line(Line), Intersection(Collinear, Parallel, HitEndpointL1, HitEndpointL2, IntersectsAt, NoIntersection))

import Graphics.Slicer.Math.GeometricAlgebra (GNum(G0, GEMinus, GEPlus, GEZero), GVal(GVal), GVec(GVec), (∧), (⋅), (•), addValPair, subValPair, addVal, subVal, addVecPair, subVecPair, mulScalarVec, divVecScalar, innerProduct, outerProduct, scalarIze)

-- Our 2D plane coresponds to a Clifford algebra of 2,0,1.

-- | Check if/where two lines intersect.
lineIntersection :: Line -> Line -> Intersection
lineIntersection l1@(Line p1 s1) l2@(Line p2 s2)
  | meet2PLine2 (eToPLine2 l1) (eToPLine2 l2) == PPoint2 (GVec []) = Collinear
  | (lineToVec l1) ∧ (lineToVec l2)           == GVec []           = Parallel
  | onSegment l1 (intersection) && onSegment l2 intersection && intersection == p1 = HitEndpointL1 p1
  | onSegment l1 (intersection) && onSegment l2 intersection && intersection == addPoints p1 s1 = HitEndpointL1 $ addPoints p1 s1
  | onSegment l1 (intersection) && onSegment l2 intersection && intersection == p2 = HitEndpointL2 p2
  | onSegment l1 (intersection) && onSegment l2 intersection && intersection == addPoints p2 s2 = HitEndpointL2 $ addPoints p2 s2
  | onSegment l1 (intersection) && onSegment l2 intersection = IntersectsAt intersection
  | otherwise = NoIntersection
  where
    intersection = intersectionPoint l1 l2
    lineToVec (Line _ (Point2 (x,y))) = GVec $ foldl addVal [] [ GVal x [GEZero 1] , GVal y [GEPlus 1] ] 

-- | Combine consecutive lines. expects lines with their end points connecting, EG, a contour generated by makeContours.
combineConsecutiveLines :: [Line] -> [Line]
combineConsecutiveLines lines
  | length lines > 1 = combineEnds $ foldt combine [last lines] ((:[]) <$> init lines)
  | otherwise = lines
  where
    combine :: [Line] -> [Line] -> [Line]
    combine  l1       [] = l1
    combine  []       l2 = l2
    combine [l1] [l2]    = if canCombineLines l1 l2 then [combineLines l1 l2] else l1 : [l2]
    combine [l1] (l2:ls) = if canCombineLines l1 l2 then combineLines l1 l2 : ls else l1:l2:ls
    combine  l1  [l2]    = if canCombineLines (last l1) l2 then init l1 ++ [combineLines (last l1) l2] else l1 ++ [l2]
    combine  l1  (l2:ls) = if canCombineLines (last l1) l2 then init l1 ++ combineLines (last l1) l2 : ls else l1 ++ l2:ls
    combineEnds :: [Line] -> [Line]
    combineEnds  []      = []
    combineEnds  [l1]    = [l1]
    combineEnds  (l1:ls)
      | length ls > 1 = if canCombineLines (last ls) l1 then init ls ++ [combineLines (last ls) l1] else l1:ls
      | otherwise = combine [l1] ls
    -- Combine lines (p1 -- p2) (p3 -- p4) to (p1 -- p4). We really only want to call this
    -- if p2 == p3 and the lines are parallel (see canCombineLines)
    combineLines :: Line -> Line -> Line
    combineLines (Line p _) (Line p1 s1) = llineFromEndpoints p (addPoints p1 s1)
    -- | Create a euclidian line given it's endpoints.
    llineFromEndpoints :: Point2 -> Point2 -> Line
    llineFromEndpoints p1@(Point2 (x1,y1)) (Point2 (x2,y2)) = Line p1 (Point2 (x2-x1,y2-y1))
    -- | determine if two euclidian line segments are on the same projective line, and if they share a middle point.
    canCombineLines :: Line -> Line -> Bool
    canCombineLines l1@(Line p1 s1) l2@(Line p2 _) = sameLine && sameMiddlePoint
      where
        sameLine = meet2PLine2 (eToPLine2 l1) (eToPLine2 l2) == PPoint2 (GVec [])
        sameMiddlePoint = p2 == addPoints p1 s1

-- | given the result of intersectionPoint, find out whether this intersection point is on the given segment, or not.
onSegment :: Line -> Point2 -> Bool
onSegment (Line p s) i =
  (sqNormOfPLine2 (join2PPoint2 (eToPPoint2 p) (eToPPoint2 i))) <= segmentLength &&
  (sqNormOfPLine2 ( join2PPoint2 (eToPPoint2 i) (eToPPoint2 (addPoints p s)))) <= segmentLength
  where
    segmentLength = sqNormOfPLine2 (join2PPoint2 (eToPPoint2 p) (eToPPoint2 (addPoints p s)))

intersectionPoint :: Line -> Line -> Point2
intersectionPoint l1 l2 = Point2 $ ((-1) * (valOf $ getVals [GEZero 1, GEPlus 2] pPoint), valOf $ getVals [GEZero 1, GEPlus 1] pPoint)
  where
    pPoint = (\(PPoint2 (GVec vals)) -> vals) $ canonicalizePPoint2 $ meet2PLine2 (eToPLine2 l1) (eToPLine2 l2)
    valOf :: [GVal] -> ℝ
    valOf [] = 0
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values."

-- | A projective point in 2D space.
newtype PPoint2 = PPoint2 GVec
  deriving (Eq, Generic, NFData, Show)

-- | A projective line in 2D space.
newtype PLine2 = PLine2 GVec
  deriving (Eq, Generic, NFData, Show)

-- our join operator, which is the meet operator operating in the dual space.
(∨) :: GVec -> GVec -> GVec
(∨) a b = dual2DGVec ((dual2DGVec a) ∧ (dual2DGVec b))

-- | our join function.
join :: GVec -> GVec -> GVec
join v1 v2 = v1 ∨ v2

-- | a typed join function. join two points, returning a line.
join2PPoint2 (PPoint2 v1) (PPoint2 v2) = PLine2 $ join v1 v2

-- | A typed meet function. two lines meeet at a point.
meet2PLine2 :: PLine2 -> PLine2 -> PPoint2
meet2PLine2 (PLine2 v1) (PLine2 v2) = PPoint2 $ v1 ∧ v2

-- | Create a 2D projective point from a 2D euclidian point.
eToPPoint2 :: Point2 -> PPoint2
eToPPoint2 (Point2 (x,y)) = PPoint2 $ GVec $ foldl addVal [GVal 1 [GEPlus 1, GEPlus 2]] [ GVal (-x) [GEZero 1, GEPlus 2], GVal y [GEZero 1, GEPlus 1] ]

-- | Create a 2D Euclidian point from a 2D Projective point.
ppointToPoint2 :: PPoint2 -> Maybe Point2
ppointToPoint2 (PPoint2 (GVec vals)) = if infinitePoint
                                      then Nothing
                                      else Just $ Point2 (xVal, yVal)
  where
    xVal = (-1) * (valOf $ getVals [GEZero 1, GEPlus 2] $ vals)
    yVal = valOf $ getVals [GEZero 1, GEPlus 1] $ vals
    infinitePoint = 0 == valOf (getVals [GEPlus 1, GEPlus 2] vals )
    valOf :: [GVal] -> ℝ
    valOf [] = 0
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values."

-- | Create a 2D projective line from a pair of euclidian endpoints.
eToPLine2 :: Line -> PLine2
eToPLine2 (Line (Point2 (x1,y1)) (Point2 (x,y))) = PLine2 $ GVec $ foldl addVal [] [ GVal c [GEZero 1], GVal a [GEPlus 1], GVal b [GEPlus 2] ]
  where
    x2=x1+x
    y2=y1+y
    a=y2-y1
    b=x1-x2
    c=y1*x2-x1*y2

-- | Convert from a PPoint2 to it's associated PLine.
dualPPoint2 :: PPoint2 -> GVec
dualPPoint2 (PPoint2 vec) = dual2DGVec vec
-- | Convert from a PLine to it's associated projective point.
dualPLine2 :: PLine2 -> GVec
dualPLine2 (PLine2 vec) = dual2DGVec vec

dual2DGVec :: GVec -> GVec
dual2DGVec uncooked = GVec $ foldl addVal []
                     [
                       (GVal                  realVal [GEZero 1, GEPlus 1, GEPlus 2])
                     , (GVal (        valOf $ getVals [GEZero 1] vals)  [GEPlus 1, GEPlus 2])
                     , (GVal ((-1) * (valOf $ getVals [GEPlus 1] vals)) [GEZero 1, GEPlus 2])
                     , (GVal (        valOf $ getVals [GEPlus 2] vals)  [GEZero 1, GEPlus 1])
                     , (GVal (        valOf $ getVals [GEZero 1, GEPlus 1] vals)  [GEPlus 2])
                     , (GVal ((-1) * (valOf $ getVals [GEZero 1, GEPlus 2] vals)) [GEPlus 1])
                     , (GVal (        valOf $ getVals [GEPlus 1, GEPlus 2] vals)  [GEZero 1])
                     , (GVal (        valOf $ getVals [GEZero 1, GEPlus 1, GEPlus 2] vals) [G0])
                     ]
  where
    (realVal, (GVec vals)) = scalarIze uncooked
    valOf :: [GVal] -> ℝ
    valOf [] = 0
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values. Impossible."

-- | Extract a value from a vector.
getVals :: [GNum] -> [GVal] -> [GVal]
getVals num vs = filter (\(GVal _ n) -> n == num) vs

canonicalizePPoint2 :: PPoint2 -> PPoint2
canonicalizePPoint2 (PPoint2 vec@(GVec vals)) = PPoint2 $ divVecScalar vec $ valOf $ getVals [GEPlus 1, GEPlus 2] vals
  where
    valOf :: [GVal] -> ℝ
    valOf [] = 1
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values."

-- The idealized norm of a euclidian projective point.
idealNormPPoint2 :: PPoint2 -> ℝ
idealNormPPoint2 (PPoint2 (GVec vals)) = sqrt (x*x+y*y)
  where
    x = (-1) * (valOf $ getVals [ GEZero 1, GEPlus 2] vals)
    y = valOf $ getVals [ GEZero 1, GEPlus 1] vals
    valOf :: [GVal] -> ℝ
    valOf [] = 0
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values. Impossible."

normOfPLine2 :: PLine2 -> ℝ
normOfPLine2 (PLine2 (GVec vals)) = sqrt (a*a+b*b)
  where
    a = valOf $ getVals [GEPlus 1] vals
    b = valOf $ getVals [GEPlus 2] vals
    valOf :: [GVal] -> ℝ
    valOf [] = 0
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values. Impossible."

sqNormOfPLine2 :: PLine2 -> ℝ
sqNormOfPLine2 (PLine2 (GVec vals)) = a*a+b*b
  where
    a = valOf $ getVals [GEPlus 1] vals
    b = valOf $ getVals [GEPlus 2] vals
    valOf :: [GVal] -> ℝ
    valOf [] = 0
    valOf [GVal v _] = v
    valOf (_:_) = error $ "found multiple values. Impossible."

-- | A contour in 2D projective space. 
data PContour =
  -- For a PLineSequence, the edges of the object are the lines, in order, with the right side of the line pointing toward 'inner' space.
  -- For a PLine parallel with the X axis, we will have to manually test inward/outwardness.
  PLineSequence [PLine2] 
  deriving (Eq, Generic, NFData, Show)

-- | Create a projective contour, from a linear (point based) contour.
-- Use the same center point for all layers to make use of haskell's laziness.
--projectContour :: Contour -> Point2 -> PContour
{-projectContour (PointSequence points) centerPoint = (toProjectivePoint $ toOriginPoint centerPoint) <$> map toGeometricPoint points
  where
    plineFromPoints p1@(Point2 (x1,y1)) p2@(Point2 (x2,y2)) = error "not yet implemented." -- joinPoints (goemetricPoint 
-}

